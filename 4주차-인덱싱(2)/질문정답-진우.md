### 1. 다음 그림을 참고하여 LSM 트리 삽입 방식을 설명하시오.
---
LSM 트리에 레코드가 처음 삽입될 때, 인메모리 B+ 트리 구조인 L0 에 레코드가 삽입된다. L0 트리에 할당된 메모리를 채우게 되면, 데이터를 인메모리 구조에서 디스크상의 B+ 트리로 이동한다. 
<br>
트리 L1 이 비어있는 경우, 전체 인메모리 트리 L0이 디스크에 쓰여 초기 트리 L1을 생성한다. 그러나 비어있지 않은 경우, L0의 단말노드를 오름차순으로 검사하면서, 해당 엔트리를 L1의 단말 노드의 엔트리와 합병한다. 합병한 엔트리로 구성된 새로운 트리가 이전 L1 을 대체한다. 이후 L0과 이전 L1 의 모든 엔트리는 삭제된다.

<br>

### 2. 위의 삽입 방식의 이점을 설명하시오.
---
1. 새로운 트리의 단말 노드는 순차적으로 배치되기 때문에, 후속 합병 과정 중 발생할 수 있는 임의의 I/O 를 방지할 수 있다.
2. 단말 노드가 가득 차게 되므로 페이지 분할로 인해 노드가 부분적으로 채워지는 오버헤드를 방지할 수 있다.

<br>

### 3. B+ 트리와 비교하여 LSM 트리의 장점을 설명하시오. 
---
1. 쓰기 성능 : LSM 트리는 쓰기 작업에 특히 효과적이다. LSM 트리는 쓰기 작업을 주로 메모리 상의 최하위 계층에서 수행하고, 복사와 병합 작업을 통해 디스크에 기록한다. 이로 인해 디스크에 대한 쓰기 작업을 최소화할 수 있다. 반면 B+ 트리는 매 쓰기 작업마다 디스크에 직접 기록하는 방식을 사용하기 때문에 쓰기 성능이 LSM 트리보다 낮을 수 있다.
2. 병합 작업 : LSM 트리는 주기적으로 상위 계층과 하위 계층의 데이터를 병합하는 작업을 수행하는데, 이를 통해 중복 데이터를 제거하고 디스크 공간을 효율적으로 사용할 수 있다. 또한 병합 작업을 통해 인덱스의 크기를 줄이고 데이터의 정렬된 순서를 유지하여 검색 성능을 향상시킬 수 있다.

<br>

### 4. 비트맵 인덱스의 정의와 특성에 대해 설명하시오.
---
비트맵 인덱스는 데이터의 존재 여부를 비트 형태로 표현하여 빠른 검색을 가능하게 한다. 비트맵 인덱스의 장점은 빠른 검색 속도와 적은 공간 사용량이다. 하지만 데이터의 카디널리티(cardinality) 가 큰 경우에는 비트맵 인덱스의 크기가 매우 커질 수 있으며, 업데이트 작업에 대한 오버헤드가 발생할 수 있다. 따라서, 비트맵 인덱스는 주로 카디널리티가 낮은 속성이나 열에 대한 인덱싱에 적합하다.

<br>

### 5. 릴레이션 instructor_info 의 income_level 속성은 아래와 같이 5개의 값을 가질 수 있다. 이때, income_level 에 대한 비트맵을 작성하시오.
---
![KakaoTalk_Photo_2023-07-08-14-19-18](https://github.com/AZ-backend-study/Database/assets/98975580/71bf0101-05f8-4b9c-910e-66365efcaa2a)


### 6. 아래 query을 참고하여 비트맵의 교집합을 수행하시오. 
---
비트연산에서는 둘 다 1이면 1의 값을 가지고 그 외에는 모두 0의 값을 가진다. 따라서 gender = m(10010) 비트맵과 income_level = L4(00010) 의 비트맵 교집합은 00010 비트맵이고 해당 비트맵이 가리키는 id는 3이다.

<br>

### 7. 주어진 점 (7,2), (5,4), (9,6), (2,3), (4,7), (8,1)을 K-d 트리에 차례로 삽입하는 과정을 설명하고 이에 대한 공간분할을 그림으로 나타내시오.
---
![IMG_F2E1CD039F6D-1](https://github.com/AZ-backend-study/Database/assets/98975580/b60a5ed5-e3d2-4c27-b34c-21f245b93267)

1. (7,2) 이 루트 자리를 차지
2. (5,4) 는 x 값이 루트의 7보다 작으므로 왼쪽 자식이 된다.
3. (9,6) 는 x 값이 루트의 7보다 크므로 오른쪽 자식이 된다.
4. (2,3) 는 x 값이 루트의 7보다 작으므로 루트의 왼쪽으로 가서 (5,4) 를 만난다. 이후 y 값이 4보다 작으므로 (5,4)의 왼쪽 자식이 된다.
5. (4,7) 는 x 값이 루트의 7보다 작으므로 루트의 오른쪽으로 가서 (5,4) 을 만난다. 이후 (5,4) 의 y 값보다 크므로 오른쪽 자식이 된다.
6. (8,1) 는 x 값이 루트의 7보다 크므로 루트의 오른쪽으로 가서 (9,6) 을 만난다. (9,6) 보다 y 값이 작으므로 (9,6)의 왼쪽 자식이 된다.

<br>

### 8. R-tree 에 대해 간략하게 설명하시오.
    다차원의 공간 데이터를 효과적으로 저장하고 지리정보와 관련된 질의를 빠르게 수행 할 수 있는 트리 자료 구조
R-tree 를 이해하기 위해 중요한 개념이 있는데 MBR 이라는 개념이다. MBR(Minimum Bounding Rectangle) 는 도형을 감싸는 최소 크기의 사각형을 의미한다. 상위 레벨의 MBR 은 하위 레벨의 MBR 들을 포함하는 계층적인 트리 구조를 R-Tree 라고 한다.
![image](https://github.com/AZ-backend-study/Database/assets/98975580/1912fdcd-1679-4b21-b24a-1324dde0b2f9)

예를 들어 다음과 같은 공간 데이터가 존재한다고 할 때, 이들을 효과적으로 검색하기 위해 인덱스를 만든다. 공간 데이터를 MBR 로 그룹화한 모습을 아래와 같이 나타낼 수 있고 각각의 MBR 들은, 그들을 그룹화한 차상위 레벨의 MBR 에 포함된다.
![image](https://github.com/AZ-backend-study/Database/assets/98975580/821caeaf-57bc-48e9-b139-02da06ad0153)
![image](https://github.com/AZ-backend-study/Database/assets/98975580/d8e37778-40c1-4506-8235-06f9f256cdef)
이렇듯 공간을 MBR 그룹으로 나눔으로써 해당 공간 데이터를 찾아 들어갈 수 있는 인덱스의 형태가 만들어진다. 최상위 MBR 은 루트 노드에 저장되는 정보이며, 차상위 그룹은 브랜치 노드가 된다. 마지막으로 각 도형의 객체는 리프노느에 저장되므로 R-tree 인덱스의 내부를 표현할 수 있다. R 트리는 B+ 트리와 유사하게 단말 노드에 객체를 인덱스하고 있는 균형 트리 구조다.