## 고정 길이 레코드
* Q1. 고정 길이 레코드 방식을 사용했을 때의 문제점을 서술하시오.
---
길이가 고정되어 있기 때문에, 각 블록이 고정 길이의 배수가 되지 않으면 몇몇 레코드는 저장될 때 블록 경계를 넘게된다. 그러면, 그 레코드에 접근하기 위해서는 두개의 블록에 모두 접근해야 하는 문제점이 생긴다. 그리고 삭제했을 때 그 공간을 다른 레코드로 채워야하는데 삭제되었다는 표시를 남기는 것이 어렵다(?)
* Q2. 그리고 위의 문제점을 해결하기 위한 방식들을 설명하시오.
---
첫번째 문제를 해결하기 위해서는 블록의 크기를 레코드 길이로 나눈 후, 소수 부분은 무시하고 저장하면 된다. 두번째 문제를 해결하기 위해서는, 가장 쉽게 생각할 수 있는 방식은 삭제한 레코드가 있던 빈 곳을 채우기 위해 모든 레코드를 이동하는 것이다. 하지만 많은 수의 레코드를 이동시켜야 하기 때문에 바람직하지 않다. 그래서 삭제한 레코드가 있던 공간에 마지막 레코드를 단순히 이동시키는 방법도 있겠지만, 레코드 삽입이 삭제보다 더 자주 일어나야 되기 때문에 다음에 삽입할 레코드를 기다리게 할 수 있다. 바람직한 방법이 아니다. 따라서 파일 앞부분에 일부 바이트를 할당해 파일 헤더를 만드는 방식을 생각해볼 수 있다. 헤더에는 내용이 삭제된 첫 번째 레코드의 주소, 그리고 이용 가능한 두 버째 레코드의 주소를 마치 링크드 리스트 형태로 저장할 수 있다.

## 파일에 레코드를 구성하는 방법
1. 힙 파일 구성
* Q1. 빈 곳이 있는 블록을 효율적으로 찾기 위해 사용하는 데이터 구조가 무엇이에 이에 대해 간단하게 설명하시오.
---
대부분 데이터 베이스는 여유 공간 맵이라고 하는 공간 효율적 데이터 구조를 사용해서 레코드를 저장할 여유 공간이 있는 블록을 추적한다. 한 개의 엔트리를 포함하는 배열로 여유 공간 맵을 흔히 나타내는데, 각 엔트리는 비율 f 를 표현한다. 이는 최소 비율 f 만큼이 해당 블록 공간에 비어 있어야 한다는 것을 뜻한다. 주어진 크기의 새 레코드를 저장할 블록을 찾기 위해 데이터베이스는 여유 공간 맵을 스캔하여 여유 공간이 있는 블록을 찾을 수 있다. 만약 없다면 릴레이션에 새로운 블록을 할당한다.
* 흠 릴레이션과 블록의 관계는 뭐지 ? 하나당 하나의 블록이 할당되는 건 아닌것 같고

2. 순차 파일 구성
* Q1. 순차 파일 구성의 한계점에 대해 설명하시오.
---
검색 키를 기준으로 순차적으로 레코드를 연결하여 빠르게 탐색할 수 있다는 장점이 있다. 하지만 시간이 지남에 다라 검색 키 순서와 물리적 순서 사이의 일치가 달라질 수 있어 순차적인 순서가 되도록 파일을 재구성해야 한다. 이런 재구성은 비용이 많이 들고 시스템 작업량이 낮을 때 해야 한다. 이 문제는 B+- 트리 파일 구성으로 해소한다.

## 버퍼
* Q1. 버퍼가 왜 필요한지 설명하시오.
---
데이터베이스의 데이터는 디스크에 상주하기 때문에 이를 읽거나 갱신하기 위해서는 메모리로 불러들여야 한다. 이때 디스크와 메모리 사이의 블록의 전송 수를 최소화시킬 필요가 있는데 이를 위해 메인 메모리에 가능한 한 많은 블록을 유지하는 방법이 있다. 하지만 메인 메모리의 모든 블록을 유지하는 것은 불가능하므로 일부의 공간을 할당할 필요가 있는데 이를 버퍼라고 한다.

## 열 지향 저장소
* Q1. 열 지향 저장소는 특정 속성에만 계속적으로 접근할 때, 즉 데이터 분석 질의에 매우 적합하다. 반면 행 기반 저장소는 모든 속성을 가져오기 때문에 필요 없는 속성까지 가져와 낭비시키므로 위의 경우에 적합하지 않다.
* Q2. 1. 캐시 성능을 향상시킬 수 있다. 열 지향 저장소에서 값 가져올 떄 연속된 바이트 메모리에서 cpu 캐시로 읽힌다. 이때 행 기반 저장소는 서로 관련없는 속성값도 저장하기 때문에 캐시 공간을 낭비하는데 이에 반해 열 지향 저장소는 연속적인 값을 더 빠르게 가져올 수 있다. 2.같은 타입의 값을 함께 저장하면 압축 효과가 증가한다. 3. 벡터 처리 : 열 단위로 데이터를 저장하면 벡터 처리를 할 수 있다. 